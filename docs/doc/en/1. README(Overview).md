> **Notice and Disclaimer**
> 
> **Nature of This Documentation**  
> This documentation contains community-researched and independently interpreted Call of War game mechanics,
> derived from player observation, testing, and community discussions.
> 
> **No Official Affiliation**  
> This project is an independent, community-driven effort and is not affiliated with, endorsed by,
> or representative of Bytro Labs GmbH or any official Call of War development.
> 
> **Accuracy Disclaimer**  
> The described mechanics represent an equivalent model derived from observable in-game behavior.
> 
> They are not guaranteed to match internal implementations and may change with future updates.
> 
> **Intellectual Property**  
> "Call of War" is a trademark of Bytro Labs GmbH. All game-related trademarks,
> assets, and content remain the property of their respective owners.
> 
> **License**  
> Documentation content authored for this project (excluding any game assets)
> is licensed under  
> Creative Commons Attribution 4.0 International (CC BY 4.0).
> 
> ---
> *Document Version: 1.0 | Last Updated: 2026-01-24*

# Overview

This documentation set (i.e., all documents within this directory) is intended to explain
**how combat mechanics are modeled** and **which game features are incorporated**
in the CoW Battle Simulator (hereafter referred to as *the Calculator*),
so that readers can understand both the origin of computed results and the logical structure behind them.

The mechanisms described here are **not official documentation**.
They represent an inferred model constructed from *player testing*, *empirical observations*, and *community research*.
As such, they may differ from the game’s true internal implementation and may become invalid as the game evolves.

## Table of Contents

1. [README (Overview)](1.%20README(Overview).md)
2. [Land Combat](2.%20Land%20Combat.md)
3. [Air Combat](3.%20Air%20Combat.md)
4. [Damage Resolution](4.%20Damage%20Resolution.md)
5. [Buildings and Modifiers](5.%20Buildings%20and%20Modifiers.md)
6. [References](6.%20References.md)

---

## Introduction to the Calculator

The combat resolution logic of Call of War (hereafter *CoW*) is, at its core, relatively simple.
With sufficient abstraction, it can be reduced to a computational blueprint such as the following:

```python
import random

As = 650
Es = 580
a = 650.0
b = 322 * 0.5
e = 580.0
f = 280 * 0.5
threshold = 0.001
iteration_count = 0

print("Double-variable iterative computation begins:")
while a > threshold and e > threshold:
    # Compute c
    if a == 650:
        c = b * random.uniform(0.8, 1.2)
    else:
        c = b * (1 - (As - a) / As * 0.8) * random.uniform(0.8, 1.2)

    # Compute g
    if e == 580:
        g = f * random.uniform(0.8, 1.2)
    else:
        g = f * (1 - (Es - e) / Es * 0.8) * random.uniform(0.8, 1.2)

    # Update variables
    a = a - g
    e = e - c
    iteration_count += 1

    print(f"Iteration {iteration_count}:")
    print(f"  c={c:.4f}, g={g:.4f}")
    print(f"  a={a:.4f}, e={e:.4f}")
    print("-" * 30)

print(f"\nFinal result: after {iteration_count} iterations")
print(f"Final a: {a:.4f}, Final e: {e:.4f}")
```

The above snippet represents an early “prototype model” constructed by the project owner `i113w` during the initial phase of development.
It illustrates that combat in CoW is fundamentally an **iterative process of computing damage efficiency, resolving damage, and applying damage** [¹](6.%20References.md#¹), repeated until one side is determined to be defeated.

Even when considering variants such as *air-to-ground combat* or *bidirectional engagements*, the underlying logic remains consistent.
For example:

* *Air-to-ground combat*:

  ```python
  import random

  As = 1150
  Es = 700
  a = 1150.0
  b = 20
  e = 700.0
  f = 135
  threshold = 0.001
  iteration_count = 0

  print("Double-variable iterative computation begins:")
  while a > threshold and e > threshold:
      # Compute c
      if a == 1150:
          c = b * random.uniform(0.8, 1.2)
      else:
          c = b * (1 - (As - a) / As * 0.8) * random.uniform(0.8, 1.2)

      e = e - c
      # Compute g
      if e == 700:
          g = f
      else:
          g = f * (1 - (Es - e) / Es * 0.8) * random.uniform(0.8, 1.2)

      # Update variables
      a = a - g

      iteration_count += 1

      print(f"Iteration {iteration_count}:")
      print(f"  c={c:.4f}, g={g:.4f}")
      print(f"  a={a:.4f}, e={e:.4f}")
      print("-" * 30)

  print(f"\nFinal result: after {iteration_count} iterations")
  print(f"Final a: {a:.4f}, Final e: {e:.4f}")
  ```

* *Bidirectional combat between identical unit types*:

  ```python
  import random

  s = 20
  a = 20.0
  b = 2.5
  threshold = 0.001  # stopping threshold
  iteration_count = 0  # iteration counter

  while a > threshold:
      if a == 20:
          c = b * random.uniform(0.8, 1.2)
      else:
          c = b * (1 - (s - a) / s * 0.8) * random.uniform(0.8, 1.2)

      a = a - c
      iteration_count += 1
      print(f"Round {iteration_count}: c={c:.3f}, a={a:.3f}")

  print(f"\nFinal result: after {iteration_count} rounds, a={a:.3f}")
  ```

---

## Next Part

This document provides only a high-level overview of the **overall combat model** adopted by the Calculator and the conceptual approach behind its early prototypes.
It does not yet elaborate on specific mechanics, parameter definitions, or edge-case behaviors.

To explore the formal definitions, calculation order, and special rules governing each combat mechanic, please continue to the next section:

➡ **[Part II: Land Combat](2.%20Land%20Combat.md)**

From that point onward, the Calculator’s rules and assumptions will be decomposed and documented module by module.