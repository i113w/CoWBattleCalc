> **Notice**  
> This document is part of an independent, unofficial analysis of *Call of War* game mechanics.  
> Licensed under CC BY 4.0 unless otherwise noted.

## Overview

This document describes the numerical model used by the Calculator to approximately reconstruct the combat resolution behavior of *Call of War*.  
It focuses on how damage values are **computed, allocated, and applied** under different engagement conditions.

---

## Damage Context

A **Damage Context** is the fundamental logical unit of localized combat resolution.  
It describes how, under a specific engagement state, a set of attack and retaliation events are generated, ordered, and resolved according to defined damage application rules.

A single Damage Context may contain **one or multiple Damage Events**, depending on the underlying combat mechanism.  
Whether these events are symmetric, and the order in which they execute, is determined by the specific combat scenario.

A Damage Context is typically **directional**, and is always defined with respect to a one-way relationship:  
**Attacker → Target**.

When both sides of an engagement are simultaneously eligible to act as attackers, **two oppositely directed Damage Contexts** will coexist between the same pair of Stacks, forming a *bilateral symmetric offensive engagement*.

---

## Damage Event

A **Damage Event** represents a single, one-directional process of damage computation and application.  
It includes attack value calculation, target filtering, damage allocation, and result application.

Damage computation within a Damage Event is performed at the **Stack level**.

During the damage application phase, total damage is first divided into multiple **damage pools** according to the different unit types present in the target Stack.  
These pools are allocated proportionally based on each unit type’s share of the Stack.

Subsequently, damage within each pool is applied at the **Unit Group** level.  
A Unit Group consists of units that share the same **type and level**  
(e.g., three level-1 infantry units form one Unit Group, while four level-2 infantry units form another).

Within each Unit Group, damage is distributed proportionally by unit count, and the survival state of the affected units is updated accordingly.

---

## Damage Efficiency

**Damage Efficiency** describes the effective offensive capability of a Unit Group when it is not at full health.  
During damage computation, efficiency is evaluated **per Unit Group** and applied as a multiplicative factor to the group’s base damage output.
$$ Eff = 0.2 + 0.8 \times \frac{\text{Current HP}}{\text{Max HP}} $$

When a Unit Group is at full HP, its damage efficiency equals 1.0.  
As current HP decreases, efficiency declines linearly, but never falls below 0.2.  
This lower bound reflects a modeling assumption that severely damaged units retain a minimal level of combat capability [⁵](6.%20References.md#⁵).

Damage efficiency is calculated independently for each Unit Group.  
Different Unit Groups within the same Stack may therefore have different efficiencies simultaneously.

During damage computation, a Unit Group’s damage efficiency is first applied to its per-unit damage values.  
Afterward, for each damage type (i.e., *vs. Armor Class damage*), the **SBDE mechanism** is applied, selecting only the **10 units with the highest effective damage** to participate in final damage aggregation.

---

## SBDE (State-Based Damage Efficiency)

> In earlier versions of CoW (CoW 1.0 / 1.5) and in historical community discussions, SBDE often referred to the number of effectively deployed units within a Stack.  
> Beyond this number, additional units would no longer increase combat power and could even reduce overall efficiency.  
>  
> Since **CoW 2.0**, this mechanism has been removed and replaced by a rule in which, for each damage type, only the **10 units with the highest damage values** are selected.  
>  
> In this documentation, **SBDE refers exclusively to this CoW 2.0 mechanism**.

### Definition

The SBDE mechanism specifies that within a Stack, regardless of total unit count, **only the 10 most effective units** may contribute damage in any single Damage Event.

SBDE does **not** simply select the first 10 units.  
Instead, selection is performed dynamically based on **effective damage against the current target’s Armor Class**.

The selection process can be summarized as follows:

1. Compute per-unit damage for each **Unit Group** against the target Armor Class  
2. Sort candidates in descending order of effective damage  
   (`candidates.sort(..., reverse=True)`)  
3. Select the top 10 units and sum their damage contributions

> *In scenarios such as Blob retaliation, this selection is performed at the **Army level**, and separating Stacks does not bypass the limitation.*

### Example

Consider a mixed Stack attacking a Light Armor target:

- Composition:  
  - 15 medium tanks (high damage vs. Light Armor)  
  - 15 infantry units (lower damage vs. Light Armor)
- **SBDE evaluation**:  
  The system automatically selects 10 units from the medium tank Unit Group to participate in damage calculation.
- **Result**:  
  The remaining 5 medium tanks and all 15 infantry units contribute **0 damage** in this Damage Event,  
  although they still share incoming damage.

Because SBDE selection is based on the **target’s Armor Class**, pure-type Stacks  
(e.g., 50 tanks) are particularly vulnerable to SBDE penalties, with 40 units contributing nothing.

In contrast, mixed Stacks (e.g., 10 artillery + 10 anti-air) may trigger different effective Top-10 selections across different Damage Contexts:

- Long-range combat → artillery selected  
- Air attack received → anti-air selected

### Evaluation Scope

SBDE limitations are evaluated **independently in each Damage Event** under the following cases:

1. **Active Attack**:  
   The attacker selects the 10 units with the highest attack damage against the target Armor Class.
2. **Passive Defense**:  
   The defender selects the 10 units with the highest defensive (retaliation) damage against the attacker’s Armor Class.
3. **Blob Retaliation**:  
   When multiple Stacks defend together, the SBDE limit applies at the **Army level**—  
   across all defending Stacks combined, only the best 10 retaliating units are selected [⁶](6.%20References.md#⁶).

---

## Context-Level Serialized Execution

Under certain special conditions—such as multiple Stacks attacking the same Stack simultaneously, or engagements involving bilateral symmetric offensive states—damage resolution exhibits **context-level serialized execution**.

Specifically:

- At the semantic level of combat rules, Damage Contexts are treated as occurring “simultaneously”.  
  However, at the implementation level, they must be resolved in a **strictly serialized order**, one after another.
- After each Damage Context completes resolution, its results are **immediately written back** to the global battlefield state.

As a consequence, subsequent Damage Contexts may be evaluated using input conditions that already reflect state changes caused by earlier contexts  
(e.g., reduced HP, lowered damage efficiency, weakened retaliation capability).  
This produces subtle but observable **micro-asymmetries** in numerical outcomes, even when the contexts are defined as simultaneous in combat logic.

In land melee combat, multiple Damage Contexts may appear visually or semantically concurrent, for example:

```yaml
Time T:
  Semantic layer:
    - Context 1: "A1 ⇄ B1"
    - Context 2: "A2 ⇄ B1"
    - Context 3: "A3 ⇄ B1"
```

In practice, the resolution process may more closely resemble the following serialized execution model:

```yaml
Time T:
  Implementation layer:
    Step 1:
      Execute: "Context 1 (A1 → B1)"
      Actions:
        - "A1 attacks B1, B1 HP: 100 → 60"
        - "B1 immediately retaliates against A1 (computed using the state at context start: 100 HP)"
        - "Battlefield state write-back completed"

    Step 2:
      Execute: "Context 2 (A2 → B1)"
      Actions:
        - "A2 attacks B1, B1 HP: 60 → 30"
        - "B1 immediately retaliates against A2 (computed using the 60 HP state)"
        - "Battlefield state write-back completed"

    Step 3:
      Execute: "Context 3 (A3 → B1)"
      Actions:
        - "..."
```

> It must be emphasized that the above order does **not** constitute an explicit priority rule.
> The exact execution order is typically not directly observable or controllable by players, nor is it guaranteed to remain consistent across different combat instances.
>
> The “context-level serialized execution” model described here is **not a direct reproduction of the game’s internal implementation**, but an abstract representation inferred from repeated combat outcomes and numerical behavior.
> In the absence of official resolution specifications, this model serves to explain and approximate observed results, while acknowledging that discrepancies may exist under certain edge conditions.

---

## Next Part

This document introduces the mechanics of **damage resolution**.
To learn about the remaining mechanics related to **buildings and modifiers**, please continue to Part V:

➡ **[Part V: Buildings and Modifiers](5.%20Buildings%20and%20Modifiers.md)**
