> **Notice**  
> This document is part of an independent, unofficial analysis of *Call of War* game mechanics.  
> Licensed under CC BY 4.0 unless otherwise noted.

## 概述
本文档描述计算器中用于近似重建 `Call of War` 战斗结算行为的数值模型，重点关注伤害数值在不同交战条件下的计算、分配与应用方式。


## 伤害上下文
伤害上下文（Damage Context）是一次局部战斗结算的逻辑单元，用于描述在特定交战状态下，若干攻击与反击事件的生成、排序与伤害应用规则。

一个伤害上下文可以包含一个或多个伤害事件，其执行顺序与是否对称由具体机制决定。

伤害上下文通常具有方向性。其定义始终基于“攻击方 → 被攻击方”的单向关系。当交战双方同时具备进攻资格时，同一对单位Stack之间将同时存在两个方向相反的伤害上下文，从而构成*双边对称进攻交战状态*。

## 伤害事件
伤害事件（Damage Event）指一次单向的伤害计算与应用过程，包括攻击值计算、目标筛选、伤害分配与结果应用。伤害事件中的伤害计算发生在`Stack`层面。

在伤害应用阶段，总伤害将首先按目标 Stack 中不同单位类型划分为若干伤害池，并依据各类型单位数量在 Stack 中所占比例进行分配。随后，每个伤害池内的伤害将按单位组（Unit Group）进行实际应用，其中单位组由“同类型、同等级的若干单位”构成（例如：3 个 1 级步兵视为一个单位组，4 个 2 级步兵视为一个单位组）。伤害在单位组内按单位数量比例结算，并更新对应单位的存活状态。


## 伤害效率
伤害效率用于描述单位组在非满血状态下的有效输出能力。在伤害计算阶段，伤害效率以**单位组**为粒度计算，并作为攻击力计算的乘数因子参与后续伤害结算。
$$ Eff = 0.2 + 0.8 \times \frac{\text{Current HP}}{\text{Max HP}} $$
当单位组处于满血状态时，其伤害效率为 1.0；随着当前生命值下降，伤害效率按线性关系降低，但始终不低于 0.2。该下限反映了单位组在严重受损情况下仍保留最低作战能力的模型假设。[⁵](6.%20%E5%8F%82%E8%80%83.md#⁵)。

伤害效率按单位组独立计算，同一 Stack 内不同单位组可能同时具有不同的伤害效率。在伤害计算阶段，单位组的伤害效率首先作用于其单体伤害值，随后在每个类型伤害（vs. class damage）中应用 SBDE 机制，仅选取伤害值最高的 10 个单位参与最终伤害汇总。

## SBDE （状态效率机制/State Based Damage Efficiency）
> 在过去的CoW（CoW 1.0/1.5）以及社区讨论中，SBDE通常指Stack中有效部署的部队数量。超过这个数量后，额外的单位不会增加Stack战斗力，反而会降低整体效率。然而自**CoW 2.0**起，相关机制已被移除，取而代之的是在类型伤害中总是选取Stack中伤害值最高的10个单位（**Top 10 规则**）。此处的SBDE**仅指CoW 2.0中的类似机制**。

### 定义
SBDE机制定义了在一个 Stack 中，无论拥有多少单位，在任意一次伤害事件中，只有**效率最高的前 10 个单位**能够输出伤害。
SBDE 不是简单地选取前 10 个单位，而是基于**针对当前目标的有效伤害**进行动态筛选。

    1. 计算每个 单位组 针对特定装甲类型的单体伤害
    2. 按伤害高低降序排列 (candidates.sort(..., reverse=True))
    3. 选取前 10 个单位累加伤害

> *（在 Blob 反击等场景下，该选择在 Army 层面统一进行，Stack 分离不会绕过限制）*

### 示例
假设有一个混合Stack进攻一支轻甲部队（Light Armor）：
- 包含：15辆中坦（对轻甲高伤）、15个步兵（对轻甲伤害较低）。
- **SBDE 判定**：系统会自动选取 10 个对轻甲伤害最高的中坦单位组对应的单位参与攻击计算。
- **结果**：剩余的 5 辆中坦和 15 个步兵在此次攻击中**贡献为 0**，但它们依然分摊受到的伤害。

由于 SBDE 是基于**目标装甲类型**进行判定的，纯兵种Stack（例如 50 个坦克）极易受到 SBDE 的惩罚（40 个坦克无贡献）。
而混合Stack（10 炮兵 + 10 防空）可以在不同类型的伤害上下文中分别触发各自的 Top 10：
- 远程 → 炮兵生效。
- 被空袭 → 防空生效。

### 计算
SBDE 限制在以下每一个伤害事件中独立结算：

1. **主动攻击 (Attack)**：攻击方选出对敌方装甲攻击力最高的 10 个单位。
2. **被动防御 (Defense)**：防守方选出对敌方装甲防御力最高的 10 个单位。
3. **Blob 反击 (Blobbing)**：当多个Stack合并防御时，SBDE 限制作用于整个 Army 层面（即所有防守Stack加起来，只选 10 个最好的反击）。[⁶](6.%20%E5%8F%82%E8%80%83.md#⁶)

## 上下文级顺序执行
在部分特殊情况下（例如多 Stack 同时攻击同一 Stack，或处于双边对称进攻交战状态的双方 Stack 之间），伤害结算会表现出“上下文级顺序执行”的特征。

具体而言：

- 各伤害上下文在战斗规则的语义层面被视为“同时发生”，但在计算实现层面，必须以**严格的串行顺序**逐一进行解析与结算；每一个上下文在完成结算后，其结果都会立即写回并更新全局战场状态。

- 因此，后续执行的伤害上下文，其计算输入条件可能已经包含前序上下文所造成的状态变化（例如单位血量变化、战斗效率下降、反击能力削弱等），从而在数值结果上产生细微但可观测的不对称性，即便这些上下文在战斗逻辑上被定义为“同时”的。

在陆战近战场景中，多个伤害上下文在视觉或规则语义上可能呈现出类似“并发发生”的效果，例如：
```yaml
时刻 T:
  语义层面:
    - 上下文1: "A1 ⇄ B1"
    - 上下文2: "A2 ⇄ B1"
    - 上下文3: "A3 ⇄ B1"
```

然而，在实际的计算实现中，结算过程可能更接近如下的顺序执行模型：
```yaml
时刻 T:
  实现层面:
    步骤1:
      执行: "上下文1（A1 → B1）"
      动作:
        - "A1 攻击 B1，B1 血量: 100 → 60"
        - "B1 立即反击 A1（基于该上下文开始时的状态计算（100HP））"
        - "战场状态写回完成"

    步骤2:
      执行: "上下文2（A2 → B1）"
      动作:
        - "A2 攻击 B1，B1 血量: 60 → 30"
        - "B1 立即反击 A2（基于 60 HP 的状态计算）"
        - "战场状态写回完成"

    步骤3:
      执行: "上下文3（A3 → B1）"
      动作:
        - "..."
```

> 需要强调的是，上述顺序并不构成显式的优先级规则，其具体执行顺序通常不可由玩家直接观测或精确控制，也不保证在不同战斗实例中保持一致。本文档所描述的“上下文级顺序执行”模型，并非对游戏内部实现的直接复现，而是基于多次战斗结果与数值行为推断得到的抽象描述。在缺乏官方结算规范的前提下，该模型用于解释与近似实际战斗结果，但不排除在特定边界条件下与真实实现存在差异。

## NEXT PART

本文档介绍了伤害结算的机制。如希望进一步了解最后的建筑、加成的相关机制，请继续阅读第五部分：

➡ **[第五部分：建筑、加成说明](5.%20%E5%BB%BA%E7%AD%91%E3%80%81%E5%8A%A0%E6%88%90.md)**