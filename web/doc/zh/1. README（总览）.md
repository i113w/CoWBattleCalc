> **Notice and Disclaimer**
> 
> **Nature of This Documentation**  
> This documentation contains community-researched and independently interpreted Call of War game mechanics,
> derived from player observation, testing, and community discussions.
> 
> **No Official Affiliation**  
> This project is an independent, community-driven effort and is not affiliated with, endorsed by,
> or representative of Bytro Labs GmbH or any official Call of War development.
> 
> **Accuracy Disclaimer**  
> The described mechanics represent an equivalent model derived from observable in-game behavior.
> 
> They are not guaranteed to match internal implementations and may change with future updates.
> 
> **Intellectual Property**  
> "Call of War" is a trademark of Bytro Labs GmbH. All game-related trademarks,
> assets, and content remain the property of their respective owners.
> 
> **License**  
> Documentation content authored for this project (excluding any game assets)
> is licensed under  
> Creative Commons Attribution 4.0 International (CC BY 4.0).
> 
> ---
> *Document Version: 1.0 | Last Updated: 2026-01-24*


# 概述
本文档（本目录下的所有文档）用于说明 CoW Battle Simulator（以下简称 *计算器*）中
**战斗机制的建模方式**与**已纳入计算的游戏特性**，
以便读者理解计算结果的来源与逻辑结构。

所描述的机制并非官方文档，而是基于 `玩家测试`、 `经验总结` 与`社区研究` 所构建的推断模型，可能与游戏的真实内部实现存在差异，亦可能因版本更新而失效。
## 目录
1. [README（总览）](1.%20README%EF%BC%88%E6%80%BB%E8%A7%88%EF%BC%89.md)
2. [陆战部分](2.%20%E9%99%86%E6%88%98%E9%83%A8%E5%88%86.md)
3. [空战部分](3.%20%E7%A9%BA%E6%88%98%E9%83%A8%E5%88%86.md)
4. [伤害结算](4.%20%E4%BC%A4%E5%AE%B3%E7%BB%93%E7%AE%97.md)
5. [建筑、加成](5.%20%E5%BB%BA%E7%AD%91%E3%80%81%E5%8A%A0%E6%88%90.md)
6. [参考](6.%20%E5%8F%82%E8%80%83.md)


## 计算器简介
Call of War（以下简称 *CoW* ）的战斗结算逻辑非常简单，动动脑子就能构建出蓝图：
```python
import random

As = 650
Es = 580
a = 650.0
b = 322 * 0.5
e = 580.0
f = 280 * 0.5
threshold = 0.001
iteration_count = 0

print("双变量迭代计算开始:")
while a > threshold and e > threshold:
    # 计算c值
    if a == 650:
        c = b * random.uniform(0.8, 1.2)
    else:
        c = b * (1 - (As - a) / As * 0.8) * random.uniform(0.8, 1.2)

    # 计算g值
    if e == 580:
        g = f * random.uniform(0.8, 1.2)
    else:
        g = f * (1 - (Es - e) / Es * 0.8) * random.uniform(0.8, 1.2)

    # 更新变量
    a = a - g
    e = e - c
    iteration_count += 1

    print(f"迭代{iteration_count}:")
    print(f"  c={c:.4f}, g={g:.4f}")
    print(f"  a={a:.4f}, e={e:.4f}")
    print("-" * 30)

print(f"\n最终结果: 经过{iteration_count}次迭代")
print(f"a终值: {a:.4f}, e终值: {e:.4f}")
```

以上为项目所有者 `i113w` 在项目初期构建的“初号机”雏形，可以发现 CoW 中的战斗本质是`计算伤害效率、结算伤害、应用伤害`[¹](6.%20%E5%8F%82%E8%80%83.md#¹)的不断迭代运算，直到其中一方被判定死亡。即便存在着空对地战斗、双向攻击等可能稍有不同的变种，但逻辑依然是相同的：
- *空对地*：
    ```python
    import random

    As = 1150
    Es = 700
    a = 1150.0
    b = 20
    e = 700.0
    f = 135
    threshold = 0.001
    iteration_count = 0

    print("双变量迭代计算开始:")
    while a > threshold and e > threshold:
        # 计算c值
        if a == 1150:
            c = b * random.uniform(0.8, 1.2)
        else:
            c = b * (1 - (As - a) / As * 0.8) * random.uniform(0.8, 1.2)

        e = e - c
        # 计算g值
        if e == 700:
            g = f
        else:
            g = f * (1 - (Es - e) / Es * 0.8) * random.uniform(0.8, 1.2)

        # 更新变量
        a = a - g

        iteration_count += 1

        print(f"迭代{iteration_count}:")
        print(f"  c={c:.4f}, g={g:.4f}")
        print(f"  a={a:.4f}, e={e:.4f}")
        print("-" * 30)

    print(f"\n最终结果: 经过{iteration_count}次迭代")
    print(f"a终值: {a:.4f}, e终值: {e:.4f}")
    ```

- *同兵种双向攻击*：
    ```python
    import random

    s = 20
    a = 20.0
    b = 2.5
    threshold = 0.001  # 设置停止阈值
    iteration_count = 0  # 记录迭代次数

    while a > threshold:  # 当a大于阈值时继续迭代
        if a == 20:
            c = b * random.uniform(0.8, 1.2)
        else:
            c = b * (1 - (s - a) / s * 0.8) * random.uniform(0.8, 1.2)

        a = a - c
        iteration_count += 1
        print(f"第{iteration_count}轮战斗: c={c:.3f}, a={a:.3f}")

    print(f"\n最终结果: 经过{iteration_count}轮战斗后,a={a:.3f}")
    ```

## NEXT PART

本文档仅对计算器所采用的整体战斗模型与早期原型思路进行了概览性说明，并未展开具体机制细节或参数行为。

若希望进一步了解各项战斗机制的具体定义、计算顺序与特殊情况，请继续阅读第二部分：

➡ **[第二部分：陆战说明](2.%20%E9%99%86%E6%88%98%E9%83%A8%E5%88%86.md)**

该部分开始将按模块拆解计算器中使用的各类规则与假设。